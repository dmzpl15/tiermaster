-- ✅ 1. Supabase SQL: DB 구조 변경 및 중복 방지
-- (1) votes 테이블에 category_id 추가 및 유저당 카테고리 1개 제한
-- (2) 기존 테이블 제거 후 재생성 (주의: 데이터 초기화됨)

-- DROP TABLES (주의: 순서 중요)
drop table if exists votes;
drop table if exists items;
drop table if exists categories;
drop table if exists groups;

-- GROUPS
create table public.groups (
id uuid primary key default uuid_generate_v4(),
name text not null,
created_at timestamp with time zone default now()
);

-- CATEGORIES
create table public.categories (
id uuid primary key default uuid_generate_v4(),
name text not null,
group_id uuid references public.groups(id) on delete cascade,
created_at timestamp with time zone default now()
);

-- ITEMS
create table public.items (
id bigint generated by default as identity primary key,
name text not null,
category_id uuid references public.categories(id) on delete cascade,
votes integer default 0,
created_at timestamp with time zone default now()
);

-- VOTES (✅ category_id 추가 + user_id + category_id 유니크)
create table public.votes (
id uuid primary key default uuid_generate_v4(),
user_id uuid references public.users(id) on delete cascade,
item_id bigint references public.items(id) on delete cascade,
category_id uuid references public.categories(id) on delete cascade,
created_at timestamp with time zone default now(),
unique (user_id, category_id) -- 한 카테고리당 하나만 추천 가능
);


//이거는 과거라서 이제 안쓴다. 
create table public.users (
id uuid primary key default uuid_generate_v4(),
email text unique not null,
name text,
profile_image text,
created_at timestamp with time zone default now(),
tier text default 'free' -- 예: free, premium, admin 등
);


//이제 이걸 쓴다. 
create table public.users (
  id uuid primary key default uuid_generate_v4(),
  email text unique not null,
  name text,
  profile_image text,
  provider_id text, -- 소셜 로그인 제공자의 ID 저장
  provider_type text, -- 'google', 'github' 등
  created_at timestamp with time zone default now(),
  tier text default 'free'
);

-- 사용자당 항목별 하나의 투표만 허용하는 고유 제약 조건 추가
ALTER TABLE votes ADD CONSTRAINT unique_user_item_vote UNIQUE (user_id, item_id);

-- ✅ 2. Supabase RPC 변경 (votes 증가)
create or replace function public.increment_votes(item_id_input bigint)
returns void as $$
begin
update public.items set votes = votes + 1 where id = item_id_input;
end;

$$
language plpgsql;

create or replace function public.decrement_votes(item_id_input bigint)
returns void as
$$

begin
update public.items set votes = greatest(votes - 1, 0) where id = item_id_input;
end;

$$
language plpgsql;
$$


==============

item_suggestions 테이블 필드 설명
이 테이블은 사용자가 제안한 항목을 관리하기 위한 것으로



CREATE TABLE item_suggestions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL, -- 제안된 항목의 이름
  description TEXT, -- 제안된 항목의 설명
  category_id UUID NOT NULL REFERENCES categories(id), -- 제안된 항목의 카테고리 ID, categories 테이블의 id를 참조하는 외래 키
  user_email TEXT NOT NULL, -- 제안한 사용자의 이메일
  user_name TEXT NOT NULL, -- 제안한 사용자의 이름
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')), -- 제안 상태 (대기, 승인, 거부)
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), -- 제안 생성 시간
  processed_at TIMESTAMP WITH TIME ZONE, -- 제안이 처리(승인 또는 거부)된 날짜와 시간
  processed_by TEXT, -- 제안을 처리한 관리자의 이메일 또는 식별자
  rejection_reason TEXT, -- 거부 사유
  item_id BIGINT REFERENCES items(id) -- 제안이 승인되어 실제 항목으로 등록된 경우, 해당 항목의 ID, items 테이블의 id를 참조하는 외래 키
); 

-- 자주 사용되는 필드에 인덱스 추가
CREATE INDEX idx_items_category ON items(category_id);
CREATE INDEX idx_votes_item_id ON votes(item_id);
CREATE INDEX idx_votes_user_id ON votes(user_id);


-- 복합 인덱스: 사용자별 항목 투표 여부 확인 (매우 빈번한 작업)
CREATE INDEX idx_votes_user_item ON votes(user_id, item_id);

-- 항목 이름 검색 최적화
CREATE INDEX idx_items_name ON items(name);

-- 카테고리 이름 검색 최적화
CREATE INDEX idx_categories_name ON categories(name);

-- 생성 시간 기준 정렬 최적화 (최신 항목 조회)
CREATE INDEX idx_items_created_at ON items(created_at DESC);

-- 인기도(votes) 기준 정렬 최적화
CREATE INDEX idx_items_votes ON items(votes DESC);

-- 제안 상태별 조회 최적화
CREATE INDEX idx_item_suggestions_status ON item_suggestions(status);



데이터베이스 인덱스 설명
인덱스는 데이터베이스 쿼리 성능을 크게 향상시키는 중요한 기능입니다. 제안된 세 개의 인덱스가 필요한지 살펴보겠습니다:

인덱스의 기본 원리
인덱스는 책의 색인과 유사합니다. 특정 정보를 빠르게 찾기 위한 구조입니다. 인덱스가 없으면 데이터베이스는 테이블의 모든 행을 확인하는 '전체 테이블 스캔'을 수행해야 합니다.

제안된 인덱스 분석
1. idx_items_category ON items(category_id)
필요성: 매우 높음

카테고리별 항목 조회는 매우 빈번한 작업입니다
예: "음식 카테고리의 모든 항목 보기", "게임 카테고리의 인기 항목 보기"
카테고리별 필터링이 없으면 전체 테이블 스캔이 발생하여 항목 수가 많아질수록 느려집니다
성능 향상 예시:
-- 인덱스 없이: 전체 테이블 스캔 (느림)
-- 인덱스 있음: 인덱스 스캔 후 필요한 행만 접근 (빠름)
SELECT * FROM items WHERE category_id = '123e4567-e89b-12d3-a456-426614174000';


2. idx_votes_item_id ON votes(item_id)
필요성: 높음

특정 항목에 대한 투표 수를 집계할 때 필수적입니다
티어 랭킹 계산, 인기 항목 정렬 등에 사용됩니다
투표 테이블은 빠르게 커질 수 있으므로 인덱스가 없으면 성능이 급격히 저하됩니다

-- 항목별 투표 수 집계
SELECT item_id, COUNT(*) FROM votes GROUP BY item_id;

-- 특정 항목의 투표 조회
SELECT * FROM votes WHERE item_id = 1234;

3. idx_votes_user_id ON votes(user_id)
필요성: 중간~높음

사용자별 투표 이력 조회에 필요합니다
"이미 투표한 항목인지 확인", "사용자의 투표 패턴 분석" 등에 사용됩니다
추천 시스템이 사용자의 이전 투표를 기반으로 작동한다면 매우 중요합니다
성능 향상 예시:

-- 사용자가 이미 투표했는지 확인
SELECT * FROM votes WHERE user_id = 'user123' AND item_id = 456;

-- 사용자의 모든 투표 이력 조회
SELECT * FROM votes WHERE user_id = 'user123';

인덱스 사용의 주의사항
장점:
조회(SELECT) 쿼리 속도 대폭 향상
정렬(ORDER BY) 및 그룹화(GROUP BY) 작업 가속화
조인(JOIN) 성능 개선
단점:
추가 저장 공간 필요 (일반적으로 문제되지 않음)
데이터 변경(INSERT, UPDATE, DELETE) 시 약간의 오버헤드
너무 많은 인덱스는 오히려 성능 저하 가능
결론
제안된 세 개의 인덱스는 모두 유용하며, 특히 데이터 규모가 커질수록 더 중요해집니다:

idx_items_category: 필수적, 카테고리별 항목 조회 가속화
idx_votes_item_id: 필수적, 항목별 투표 집계 가속화
idx_votes_user_id: 매우 유용, 사용자별 투표 이력 조회 가속화
추천 시스템이 느린 문제를 해결하기 위해서는 이러한 인덱스를 추가하는 것이 좋은 첫 번째 단계입니다. 인덱스 추가 후에도 성능 문제가 지속된다면, 쿼리 자체를 최적화하거나 캐싱 전략을 도입하는 것을 고려할 수 있습니다.