# 데이터베이스 스키마 설계

## 테이블 구조

### 기본 테이블 구조

```sql
-- GROUPS
create table public.groups (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  created_at timestamp with time zone default now()
);

-- CATEGORIES
create table public.categories (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  groups_id uuid references groups(id),
  created_at timestamp with time zone default now()
);

-- ITEMS
create table public.items (
  id bigint primary key generated by default as identity,
  name text not null,
  description text,
  category_id uuid references categories(id),
  votes bigint default 0,
  created_at timestamp with time zone default now()
);



-- VOTES
create table public.votes (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null,
  item_id bigint references items(id),
  created_at timestamp with time zone default now()
);

-- 사용자당 항목별 하나의 투표만 허용하는 고유 제약 조건
ALTER TABLE votes ADD CONSTRAINT unique_user_item_vote UNIQUE (user_id, item_id);
```

### 사용자 테이블

```sql
create table public.users (
  id uuid primary key default uuid_generate_v4(),
  email text unique not null,
  name text,
  profile_image text,
  provider_id text, -- 소셜 로그인 제공자의 ID 저장
  provider_type text, -- 'google', 'github' 등
  created_at timestamp with time zone default now(),
  tier text default 'free'
);
```

### 제안 항목 테이블

```sql
CREATE TABLE item_suggestions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL, -- 제안된 항목의 이름
  description TEXT, -- 제안된 항목의 설명
  category_id UUID NOT NULL REFERENCES categories(id), -- 제안된 항목의 카테고리 ID
  user_email TEXT NOT NULL, -- 제안한 사용자의 이메일
  user_name TEXT NOT NULL, -- 제안한 사용자의 이름
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')), -- 제안 상태
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), -- 제안 생성 시간
  processed_at TIMESTAMP WITH TIME ZONE, -- 제안이 처리(승인 또는 거부)된 날짜와 시간
  processed_by TEXT, -- 제안을 처리한 관리자의 이메일 또는 식별자
  rejection_reason TEXT, -- 거부 사유
  item_id BIGINT REFERENCES items(id) -- 제안이 승인되어 실제 항목으로 등록된 경우, 해당 항목의 ID
);
```

## 인덱스 설계

성능 최적화를 위한 인덱스:

```sql
-- 자주 사용되는 필드에 인덱스 추가
CREATE INDEX idx_items_category ON items(category_id);
CREATE INDEX idx_votes_item_id ON votes(item_id);
CREATE INDEX idx_votes_user_id ON votes(user_id);
-- 복합 인덱스: 사용자별 항목 투표 여부 확인 (매우 빈번한 작업)
CREATE INDEX idx_votes_user_item ON votes(user_id, item_id);

-- 항목 이름 검색 최적화
CREATE INDEX idx_items_name ON items(name);

-- 카테고리 이름 검색 최적화
CREATE INDEX idx_categories_name ON categories(name);

-- 생성 시간 기준 정렬 최적화 (최신 항목 조회)
CREATE INDEX idx_items_created_at ON items(created_at DESC);

-- 인기도(votes) 기준 정렬 최적화
CREATE INDEX idx_items_votes ON items(votes DESC);

-- 제안 상태별 조회 최적화
CREATE INDEX idx_item_suggestions_status ON item_suggestions(status);
```

카테고리별 항목 조회 (idx_items_category)
항목별 투표 조회 (idx_votes_item_id)
사용자별 투표 조회 (idx_votes_user_id)
사용자별 항목 투표 여부 확인 (idx_votes_user_item)
항목 이름 검색 (idx_items_name)
카테고리 이름 검색 (idx_categories_name)
최신 항목 조회 (idx_items_created_at)
인기 항목 조회 (idx_items_votes)
제안 상태별 조회 (idx_item_suggestions_status)


### 인덱스 설명

1. **idx_items_category ON items(category_id)**
   - 필요성: 매우 높음
   - 카테고리별 항목 조회는 매우 빈번한 작업
   - 카테고리별 필터링이 없으면 전체 테이블 스캔이 발생하여 항목 수가 많아질수록 느려짐

2. **idx_votes_item_id ON votes(item_id)**
   - 필요성: 높음
   - 특정 항목에 대한 투표 수를 집계할 때 필수적
   - 티어 랭킹 계산, 인기 항목 정렬 등에 사용됨

3. **idx_votes_user_id ON votes(user_id)**
   - 필요성: 중간
   - 사용자별 투표 이력 조회 시 필요
   - 중복 투표 방지 및 사용자 활동 분석에 활용




이 두 SQL 명령은 데이터베이스 성능을 최적화하기 위한 인덱스를 생성하는 코드입니다:

1. CREATE INDEX IF NOT EXISTS idx_votes_user_item ON votes(user_id, item_id);
이 인덱스는 votes 테이블에서 user_id와 item_id 조합으로 빠르게 검색할 수 있게 해줍니다.
사용자가 특정 항목에 이미 투표했는지 확인할 때 성능을 크게 향상시킵니다.
중복 투표 방지 검사가 훨씬 빨라집니다.
2. CREATE INDEX IF NOT EXISTS idx_items_id ON items(id);
이 인덱스는 items 테이블의 id 필드에 대한 검색을 최적화합니다.
기본적으로 주키(Primary Key)는 자동으로 인덱싱되므로, 이 인덱스는 id가 주키가 아닌 경우에만 필요합니다.
투표 수 업데이트나 항목 정보 조회 시 성능을 향상시킵니다.
이 인덱스들은 투표 관련 작업(추가/삭제)과 항목 조회 시 데이터베이스 쿼리 속도를 크게 개선해 줄 수 있습니다. 특히 데이터가 많아질수록 인덱스의 효과는 더 커집니다.


 CREATE INDEX IF NOT EXISTS idx_votes_user_item ON votes(user_id, item_id);
CREATE INDEX IF NOT EXISTS idx_items_id ON items(id);
