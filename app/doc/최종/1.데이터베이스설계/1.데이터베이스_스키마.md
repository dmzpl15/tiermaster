# 데이터베이스 스키마 설계

## 테이블 구조

### 기본 테이블 구조

```sql
-- GROUPS
create table public.groups (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  created_at timestamp with time zone default now()
);

-- CATEGORIES
create table public.categories (
  id uuid primary key default uuid_generate_v4(),
  name text not null,
  groups_id uuid references groups(id),
  created_at timestamp with time zone default now()
);

-- ITEMS
create table public.items (
  id bigint primary key generated by default as identity,
  name text not null,
  description text,
  category_id uuid references categories(id),
  votes bigint default 0,
  created_at timestamp with time zone default now()
);



-- VOTES
create table public.votes (
  id uuid primary key default uuid_generate_v4(),
  user_id uuid not null,
  item_id bigint references items(id),
  created_at timestamp with time zone default now()
);

-- 사용자당 항목별 하나의 투표만 허용하는 고유 제약 조건
ALTER TABLE votes ADD CONSTRAINT unique_user_item_vote UNIQUE (user_id, item_id);
```

### 사용자 테이블

```sql
create table public.users (
  id uuid primary key default uuid_generate_v4(),
  email text unique not null,
  name text,
  profile_image text,
  provider_id text, -- 소셜 로그인 제공자의 ID 저장
  provider_type text, -- 'google', 'github' 등
  created_at timestamp with time zone default now(),
  tier text default 'free'
);
```

### 제안 항목 테이블

```sql
CREATE TABLE item_suggestions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  name TEXT NOT NULL, -- 제안된 항목의 이름
  description TEXT, -- 제안된 항목의 설명
  category_id UUID NOT NULL REFERENCES categories(id), -- 제안된 항목의 카테고리 ID
  user_email TEXT NOT NULL, -- 제안한 사용자의 이메일
  user_name TEXT NOT NULL, -- 제안한 사용자의 이름
  status TEXT NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'approved', 'rejected')), -- 제안 상태
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(), -- 제안 생성 시간
  processed_at TIMESTAMP WITH TIME ZONE, -- 제안이 처리(승인 또는 거부)된 날짜와 시간
  processed_by TEXT, -- 제안을 처리한 관리자의 이메일 또는 식별자
  rejection_reason TEXT, -- 거부 사유
  item_id BIGINT REFERENCES items(id) -- 제안이 승인되어 실제 항목으로 등록된 경우, 해당 항목의 ID
);
```

## 인덱스 설계

성능 최적화를 위한 인덱스:

```sql
-- 자주 사용되는 필드에 인덱스 추가
CREATE INDEX idx_items_category ON items(category_id);
CREATE INDEX idx_votes_item_id ON votes(item_id);
CREATE INDEX idx_votes_user_id ON votes(user_id);
-- 복합 인덱스: 사용자별 항목 투표 여부 확인 (매우 빈번한 작업)
CREATE INDEX idx_votes_user_item ON votes(user_id, item_id);

-- 항목 이름 검색 최적화
CREATE INDEX idx_items_name ON items(name);

-- 카테고리 이름 검색 최적화
CREATE INDEX idx_categories_name ON categories(name);

-- 생성 시간 기준 정렬 최적화 (최신 항목 조회)
CREATE INDEX idx_items_created_at ON items(created_at DESC);

-- 인기도(votes) 기준 정렬 최적화
CREATE INDEX idx_items_votes ON items(votes DESC);

-- 제안 상태별 조회 최적화
CREATE INDEX idx_item_suggestions_status ON item_suggestions(status);
```

카테고리별 항목 조회 (idx_items_category)
항목별 투표 조회 (idx_votes_item_id)
사용자별 투표 조회 (idx_votes_user_id)
사용자별 항목 투표 여부 확인 (idx_votes_user_item)
항목 이름 검색 (idx_items_name)
카테고리 이름 검색 (idx_categories_name)
최신 항목 조회 (idx_items_created_at)
인기 항목 조회 (idx_items_votes)
제안 상태별 조회 (idx_item_suggestions_status)


### 인덱스 설명

1. **idx_items_category ON items(category_id)**
   - 필요성: 매우 높음
   - 카테고리별 항목 조회는 매우 빈번한 작업
   - 카테고리별 필터링이 없으면 전체 테이블 스캔이 발생하여 항목 수가 많아질수록 느려짐

2. **idx_votes_item_id ON votes(item_id)**
   - 필요성: 높음
   - 특정 항목에 대한 투표 수를 집계할 때 필수적
   - 티어 랭킹 계산, 인기 항목 정렬 등에 사용됨

3. **idx_votes_user_id ON votes(user_id)**
   - 필요성: 중간
   - 사용자별 투표 이력 조회 시 필요
   - 중복 투표 방지 및 사용자 활동 분석에 활용
